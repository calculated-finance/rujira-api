defmodule Rujira.Analytics.Swap.AssetBin do
  @moduledoc """
  The AssetBin schema aggregates the volume of base layer swaps by asset within defined time intervals (bins).
  This schema is essential for analyzing the performance of individual assets and understanding their contributions
  to overall swap activity. It provides insights into:

    - Volume Breakdown: Determining the total swap volume generated by each asset.
    - Asset Performance: Identifying which assets drive higher activity and potentially generate more revenue.
    - Trend Analysis: Supporting data-driven decisions by tracking how swap volumes change over time for each asset.

  """

  import Ecto.Changeset
  use Ecto.Schema
  alias Rujira.Repo
  import Ecto.Query

  @type t :: %__MODULE__{
          resolution: String.t(),
          bin: DateTime.t(),
          affiliate: String.t(),
          asset: String.t(),
          volume: non_neg_integer(),
          inserted_at: DateTime.t(),
          updated_at: DateTime.t()
        }

  # this is calculating the total volume per asset per bin from a specific affiliate
  # if more than 1 affiliate is associated with 1 swap, we weight the data by the affiliate with the bps
  @primary_key false
  schema "thorchain_swap_asset_bins" do
    field :resolution, :string, primary_key: true
    field :bin, :utc_datetime, primary_key: true
    field :affiliate, :string, primary_key: true
    field :asset, :string, primary_key: true

    field :volume, :integer

    timestamps(type: :utc_datetime_usec)
  end

  @doc false
  def changeset(bin, attrs) do
    bin
    |> cast(attrs, [:resolution, :bin, :affiliate, :asset, :volume])
    |> validate_required([:resolution, :bin, :affiliate, :asset, :volume])
  end

  def update(entries) do
    sanitized = sanitize(entries)

    __MODULE__
    |> Repo.insert_all(
      sanitized,
      on_conflict: handle_conflict(),
      conflict_target: [:resolution, :bin, :affiliate, :asset],
      returning: true
    )
  end

  defp handle_conflict do
    from(c in __MODULE__,
      update: [
        set: [
          volume: fragment("EXCLUDED.volume + ?", c.volume)
        ]
      ]
    )
  end

  defp sanitize(entries) do
    group_keys = [:resolution, :bin, :affiliate, :asset]
    fields = __MODULE__.__schema__(:fields)

    entries
    |> Enum.map(&Map.take(&1, fields))
    |> Enum.group_by(fn entry ->
      Map.take(entry, group_keys)
    end)
    |> Enum.map(fn {_, group_entries} ->
      base = hd(group_entries)

      sum_volume =
        group_entries
        |> Enum.map(& &1.volume)
        |> Enum.reduce(0, &Kernel.+/2)

      Map.put(base, :volume, sum_volume)
    end)
  end
end
